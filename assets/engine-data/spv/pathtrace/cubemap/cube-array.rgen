#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "global.glsl"
#include "random.glsl"

struct hitPayload {
	vec3 radiance; // radiance of traced ray

	vec3 origin; // next ray stuff
	vec3 direction;
	vec3 attenuation;

	int hitType; 
	// 0 - direct
	// 1 - general
	// 2 - special
	// 3 - stop
	uint seed;
};

layout(push_constant) uniform PC {
	int samples;
	int bounces;
	int pointlightCount;
	int spotlightCount;
	int dirlightCount;
	int quadlightCount;
};

layout(set = 0, binding = 0, rgba32f) uniform imageCubeArray cubeArray;
layout(set = 1, binding = 0) uniform UBO_Irragrid { Irragrid grid; };
layout(set = 2, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(location = 0) rayPayloadEXT hitPayload prd;

void TraceRay() {
	prd.radiance = vec3(0.f);

    uint  rayFlags =  gl_RayFlagsCullFrontFacingTrianglesEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

	// trace ray
	traceRayEXT(topLevelAs,     // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask - nothing
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				prd.origin,     // ray origin
				tMin,           // ray min range
				prd.direction,  // ray direction
				tMax,           // ray max range
				0               // payload (location = 0)
	);
}

bool RRTerminationCheck(inout vec3 totalAttenuation) {

	float p_spawn = min(max(totalAttenuation), 0.99);
	if(rand(prd.seed) >= p_spawn) {
		return true; 
	}

	totalAttenuation /= p_spawn;
	return false;
}

mat4 lookAtRH(vec3 eye, vec3 center, vec3 up)
{
	vec3 f = normalize(center - eye);
	vec3 s = normalize(cross(f, up));
	vec3 u = cross(s, f);

	mat4 Result = mat4(1);
	Result[0][0] = s.x;
	Result[1][0] = s.y;
	Result[2][0] = s.z;
	Result[0][1] = u.x;
	Result[1][1] = u.y;
	Result[2][1] = u.z;
	Result[0][2] =-f.x;
	Result[1][2] =-f.y;
	Result[2][2] =-f.z;
	Result[3][0] =-dot(s, eye);
	Result[3][1] =-dot(u, eye);
	Result[3][2] = dot(f, eye);
	return Result;
}

mat4 perspectiveRH_ZO(float fovy, float aspect, float zNear, float zFar)
{
	float tanHalfFovy = tan(fovy / 2.f);

	mat4 Result = mat4(0);
	Result[0][0] = 1.f / (aspect * tanHalfFovy);
	Result[1][1] = 1.f / (tanHalfFovy);
	Result[2][2] = zFar / (zNear - zFar);
	Result[2][3] = -1.f;
	Result[3][2] = -(zFar * zNear) / (zFar - zNear);
	return Result;
}

void main() {

	// PERF:
	mat4 projInverse = inverse(perspectiveRH_ZO(1.5708f, 1.f, 1.f, 25.f));
	projInverse[1][1] *= -1;

	// for each probe of the grid
	for (int x = 0; x < grid.width; ++x) {
		for (int y = 0; y < grid.height; ++y) {
			for (int z = 0; z < grid.depth; ++z) {

				int i = 0;
				i += x;
				i += y * grid.width;
				i += z * grid.width * grid.height;
				//i %= grid.builtCount;

//				 0	xx_TEXTURE_CUBE_MAP_POSITIVE_X
//				 1	xx_TEXTURE_CUBE_MAP_NEGATIVE_X
//				 2	xx_TEXTURE_CUBE_MAP_POSITIVE_Y
//				 3	xx_TEXTURE_CUBE_MAP_NEGATIVE_Y
//				 4	xx_TEXTURE_CUBE_MAP_POSITIVE_Z
//				 5	xx_TEXTURE_CUBE_MAP_NEGATIVE_Z

				vec3 probePos = grid.firstPos + (vec3(x, y, z) * grid.distToAdjacent);

				// PERF:
				mat4 viewInverses[] = {
					inverse(lookAtRH(probePos, probePos + vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0))),   // right
					inverse(lookAtRH(probePos, probePos + vec3(-1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0))),  // left
					inverse(lookAtRH(probePos, probePos + vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0))),   // up
					inverse(lookAtRH(probePos, probePos + vec3(0.0, -1.0, 0.0), vec3(0.0, 0.0, -1.0))), // down
					inverse(lookAtRH(probePos, probePos + vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0))),  // front
					inverse(lookAtRH(probePos, probePos + vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0))),   // back
				};

				for (int f = 0; f < 6; ++f) {

					vec3 accumColor = vec3(0.f);
					for(uint smpl = 0; smpl < samples; ++smpl){

						prd.seed = tea16(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, samples + smpl);
						float r1 = rand(prd.seed);
						float r2 = rand(prd.seed);

						vec2 subpixel_jitter = smpl == 0 ? vec2(0.0f, 0.0f) : vec2(r1 - 0.5f, r2 - 0.5f);

						const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + subpixel_jitter;
						const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
						vec2       d           = inUV * 2.0 - 1.0;

						vec4 target    = projInverse * vec4(d.x, d.y, 1, 1);
						vec4 direction = viewInverses[f] * vec4(normalize(target.xyz), 0);

						prd.origin = probePos.xyz;
						prd.direction = direction.xyz;

						prd.attenuation = vec3(1.f);

						prd.hitType = 0; // direct

						vec3 currentTotalAttenuation = vec3(1);
						for(int depth = 0; depth < bounces + 1 && (prd.hitType != 3); ++depth)
						{
							currentTotalAttenuation *= prd.attenuation;

							TraceRay(); 

							accumColor += prd.radiance * currentTotalAttenuation;
		
							if(depth > 4 && RRTerminationCheck(currentTotalAttenuation)) {
								break;
							}
						}
					}

					vec3 curColor = (accumColor / samples);
					imageStore(cubeArray, ivec3(gl_LaunchIDEXT.xy, i * 6u + f), vec4(curColor, 1.0));
				}
			}
		}
	}
}
