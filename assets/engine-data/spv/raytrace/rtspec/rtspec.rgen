#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable

#include "global.glsl"
#include "raytrace/rtspec/rtspec.glsl"

#include "attachments.glsl"
#include "fragment.glsl"
#include "onb.glsl"
#include "random.glsl"
#include "bsdf.glsl"

layout(set = 1, binding = 0) uniform UBO_Camera {   
	vec3 position;
	float pad0;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	mat4 viewInv;
	mat4 projInv;
	mat4 viewProjInv; 
} cam;

layout(set = 2, binding = 0, rgba32f) uniform image2D image;
layout(set = 3, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(set = 4, binding = 1) uniform sampler2D textureSamplers[];

layout(location = 0) rayPayloadEXT hitPayload prd;

vec3 RadianceOfRay(vec3 nextOrigin, vec3 nextDirection) {
	prd.radiance = vec3(0);
	prd.depth += 1;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsCullFrontFacingTrianglesEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

	// trace ray
	traceRayEXT(topLevelAs,     // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				nextOrigin,     // ray origin
				tMin,           // ray min range
				nextDirection,  // ray direction
				tMax,           // ray max range
				0               // payload (location = 0)
	);
	
    prd.depth -= 1;
	return prd.radiance;
}

void main() {
	vec2 uv = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

	float fragDepth = texture(g_DepthSampler, uv).r;

	if(fragDepth >= 1.) {
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0));
		return; 
	}

	Fragment frag = getFragmentFromGBuffer(
		fragDepth,
		cam.viewProjInv,
		g_NormalSampler,
		g_AlbedoSampler,
		g_SpecularSampler,
		g_EmissiveSampler,
		uv);

	Onb shadingBasis = branchlessOnb(frag.normal);
	vec3 V = normalize(cam.position - frag.position);
	toOnbSpace(shadingBasis, V);

	float NoV = max(Ndot(V), BIAS);

	vec3 brdfLut = (texture(std_BrdfLut, vec2(NoV, frag.a))).rgb;

	vec3 radiance = vec3(0);

	for(uint smpl = 0; smpl < samples; ++smpl){

		prd.seed = tea16(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, samples + smpl);
		prd.depth = 1; // gbuffer

		vec3 L;
		if( frag.a < 0.001){
			L = reflect(-V);
		}
		else{
			vec2 u = rand2(prd.seed);
			vec3 H = importanceSampleGGX(u, frag.a);
			L = reflect(-V, H);
		}

		// SMATH: is nol here legit?
		float NoL = max(Ndot(L), BIAS);

		outOnbSpace(shadingBasis, L);
		radiance += RadianceOfRay(frag.position, L) * (frag.f0 * brdfLut.x + brdfLut.y) * NoL;
	}
    
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance / float(samples), 1.0));
}

