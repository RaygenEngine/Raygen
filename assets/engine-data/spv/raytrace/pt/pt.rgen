#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "global.glsl"
#include "raytrace/pt/pt.glsl"

#include "random.glsl"

layout(set = 0, binding = 0, rgba32f) uniform image2D image[6];
layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(location = 0) rayPayloadEXT hitPayload prd;

mat4 lookAtRH(vec3 eye, vec3 center, vec3 up)
{
	vec3 f = normalize(center - eye);
	vec3 s = normalize(cross(f, up));
	vec3 u = cross(s, f);

	mat4 Result = mat4(1);
	Result[0][0] = s.x;
	Result[1][0] = s.y;
	Result[2][0] = s.z;
	Result[0][1] = u.x;
	Result[1][1] = u.y;
	Result[2][1] = u.z;
	Result[0][2] =-f.x;
	Result[1][2] =-f.y;
	Result[2][2] =-f.z;
	Result[3][0] =-dot(s, eye);
	Result[3][1] =-dot(u, eye);
	Result[3][2] = dot(f, eye);
	return Result;
}

mat4 perspectiveRH_ZO(float fovy, float aspect, float zNear, float zFar)
{
	float tanHalfFovy = tan(fovy / 2.f);

	mat4 Result = mat4(0);
	Result[0][0] = 1.f / (aspect * tanHalfFovy);
	Result[1][1] = 1.f / (tanHalfFovy);
	Result[2][2] = zFar / (zNear - zFar);
	Result[2][3] = -1.f;
	Result[3][2] = -(zFar * zNear) / (zFar - zNear);
	return Result;
}


vec3 RadianceOfRay(vec3 nextOrigin, vec3 nextDirection) {
	prd.radiance = vec3(0);
	prd.depth += 1;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsCullFrontFacingTrianglesEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

	// trace ray
	traceRayEXT(topLevelAs,     // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				nextOrigin,     // ray origin
				tMin,           // ray min range
				nextDirection,  // ray direction
				tMax,           // ray max range
				0               // payload (location = 0)
	);
	
    prd.depth -= 1;
	return prd.radiance;
}

void main() {

	// PERF:
	mat4 projInverse = inverse(perspectiveRH_ZO(1.5708f, 1.f, 1.f, 25.f));
	projInverse[1][1] *= -1;

	vec3 reflprobePos = reflPos.xyz;

	// PERF:
	mat4 viewInverses[] = {
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0))),   // right
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(-1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0))),  // left
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0))),   // up
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(0.0, -1.0, 0.0), vec3(0.0, 0.0, -1.0))), // down
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0))),  // front
		inverse(lookAtRH(reflprobePos, reflprobePos + vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0))),   // back
	};

	for (int i = 0; i < 6; ++i) {

		const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
		const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
		vec2       d           = inUV * 2.0 - 1.0;

		vec4 origin    = viewInverses[i] * vec4(0, 0, 0, 1);
		vec4 target    = projInverse * vec4(d.x, d.y, 1, 1);
		vec4 direction = viewInverses[i] * vec4(normalize(target.xyz), 0);

		origin = origin + innerRadius * direction;

		vec3 accumColor = vec3(0.f);

		for(uint smpl = 0; smpl < samples; ++smpl){
			prd.seed = tea16(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, samples + smpl);
			prd.depth = 1; // gbuffer 
			prd.accumThroughput = vec3(1.f);

			accumColor += RadianceOfRay(origin.xyz, direction.xyz);	 
		}

		vec3 curColor = (accumColor / samples);

		imageStore(image[i], ivec2(gl_LaunchIDEXT.xy), vec4(curColor, 1.0));
	}
}
