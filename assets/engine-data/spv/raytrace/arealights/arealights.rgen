#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query: require
// TODO:
#define RAY
#include "global.glsl"

#include "global-descset.glsl"

#include "lights/quadlight.glsl"
#include "random.glsl"
#include "surface.glsl"

struct hitPayload
{
	int shadow;
};

layout(push_constant) uniform PC
{
	int frame;
	int pointlightCount;
	int quadlightCount;
};

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 1, binding = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = 1, rgba32f) uniform image2D progressive;
layout(set = 2, binding = 0) uniform accelerationStructureEXT topLevelAs;
layout(set = 3, binding = 0, std430) readonly buffer Quadlights { Quadlight light[]; } quadlights;

void main() {
	vec2 uv = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

	Surface surface = surfaceFromGBuffer(
	    cam,
		g_DepthSampler,
		g_NormalSampler,
		g_AlbedoSampler,
		g_SpecularSampler,
		g_EmissiveSampler,
		uv
	);

	// pick 1 light
	uint seed = tea16(uint(surface.uv.y * 2160 * 4096 + surface.uv.x * 4096), frame /* * samples of lights*/);

	float u = rand(seed);

	// uniform for now, WIP: Power-proportional source selection
	int i = int(floor(u * quadlightCount));

	float p_selectLight = 1.0 / float(quadlightCount);

	Quadlight ql = quadlights.light[i];

	
	vec3 color;

	// RR  
	if(rand(seed) > p_selectLight) {
		color = Quadlight_BrdfSample(topLevelAs, ql, surface, seed) / (1.0 - p_selectLight); 
	}
	else {
		color = Quadlight_LightSample(topLevelAs, ql, surface, seed) / p_selectLight; 
	}

	// Do accumulation
	if(frame > 0)
	{
		float a = 1.0f / float(frame);
		vec3 old_color = imageLoad(progressive, ivec2(gl_LaunchIDEXT.xy)).xyz;
		color = mix(old_color, color, a);
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
	imageStore(progressive, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
}
