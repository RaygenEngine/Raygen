#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable

#include "global.glsl"
#include "rt-global.glsl"

#include "bsdf.glsl"


//
struct Material {
	// factors
	vec4 baseColorFactor;
	vec4 emissiveFactor;
	float metallicFactor;
	float roughnessFactor;
	float normalScale;
	float occlusionStrength;

	// alpha mask
	float alphaCutoff;
	int mask;

	sampler2DRef baseColor;
	sampler2DRef metallicRough;
	sampler2DRef occlusion;
	sampler2DRef normal;
	sampler2DRef emissive;
};

//
#include "raytrace/rt-callableMat.glsl"
layout(location = 0) callableDataInEXT CallableMatInOut cmat;

Material mat = geomGroups.g[nonuniformEXT(cmat.matid)].materialUbo.m;
vec2 uv = cmat.uv;

void main() {

	vec4 sampledBaseColor = texture(mat.baseColor, uv) * mat.baseColorFactor;
	vec4 sampledNormal = texture(mat.normal, uv) * mat.normalScale;
	vec4 sampledMetallicRoughness = texture(mat.metallicRough, uv);
	vec4 sampledEmissive = texture(mat.emissive, uv) * mat.emissiveFactor;


	// final material values
	vec3 baseColor = sampledBaseColor.rgb;
	float metallic = sampledMetallicRoughness.b * mat.metallicFactor;
	float roughness = sampledMetallicRoughness.g * mat.roughnessFactor;
	float reflectance = 0.5;

	// remapping
	cmat.brdfInfo.albedo = (1.0 - metallic) * baseColor;
	cmat.brdfInfo.f0 = vec3(0.16 * reflectance * reflectance * (1.0 - metallic)) + baseColor * metallic;
	cmat.brdfInfo.a = roughness * roughness;
	cmat.localNormal = sampledNormal.rgb;
	cmat.emissive = sampledEmissive.rgb;
}


