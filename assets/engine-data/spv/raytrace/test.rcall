#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable

#include "global.glsl"
#include "rt-global.glsl"

#include "random.glsl"
#include "sampling.glsl"
#include "bsdf.glsl"
#include "onb.glsl"


//
struct Material {
	// factors
	vec4 baseColorFactor;
	vec4 emissiveFactor;
	float metallicFactor;
	float roughnessFactor;
	float normalScale;
	float occlusionStrength;

	// alpha mask
	float alphaCutoff;
	int mask;

	sampler2DRef baseColor;
	sampler2DRef metallicRough;
	sampler2DRef occlusion;
	sampler2DRef normal;
	sampler2DRef emissive;
};


layout(buffer_reference, std430) buffer Vertices { Vertex v[]; };
layout(buffer_reference, std430) buffer Indicies { uint i[]; };
layout(buffer_reference, std430) buffer MaterialBufRef { Material m; };

//
#include "raytrace/rt-callableMat.glsl"

struct CallableMatInOut
{
	int matid; // Incoming Buffer reference
	vec2 uv; // Incoming UV
	
	FragBrdfInfo brdfInfo;
	
	vec3 emissive;
	vec3 localNormal;
};

layout(location = 0) callableDataInEXT CallableMatInOut cmat;



struct GeometryGroup {
	Vertices vtxBuffer;
	Indicies indBuffer;
	MaterialBufRef materialUbo;

	uint indexOffset;
	uint primOffset;

	mat4 transform;
	mat4 invTransform;
	
	int callableIndex; // callableIndex == -1 is used at the moment for gltf (mainly for debugging purposes | you can skip callable materials completely)
};

layout(set = 4, binding = 0, std430) readonly buffer GeometryGroups { GeometryGroup g[]; } geomGroups;
layout(set = 4, binding = 1) uniform sampler2D textureSamplers[];//

vec4 texture(sampler2DRef s, vec2 uv) {
	return texture(textureSamplers[nonuniformEXT(s.index)], uv);
}

Material GetMaterial(int matId) {
	return geomGroups.g[nonuniformEXT(matId)].materialUbo.m;
}


void main() {
	Material mat = GetMaterial(cmat.matid);
	vec2 uv = cmat.uv;
	vec4 sampledBaseColor = texture(mat.baseColor, uv) * mat.baseColorFactor;
	vec4 sampledNormal = texture(mat.normal, uv) * mat.normalScale;
	vec4 sampledMetallicRoughness = texture(mat.metallicRough, uv);
	vec4 sampledEmissive = texture(mat.emissive, uv) * mat.emissiveFactor;


	// final material values
	vec3 baseColor = sampledBaseColor.rgb;
	float metallic = sampledMetallicRoughness.b * mat.metallicFactor;
	float roughness = sampledMetallicRoughness.g * mat.roughnessFactor;
	float reflectance = 0.5;

	// remapping
	cmat.brdfInfo.albedo = (1.0 - metallic) * baseColor;
	cmat.brdfInfo.f0 = vec3(0.16 * reflectance * reflectance * (1.0 - metallic)) + baseColor * metallic;
	cmat.brdfInfo.a = roughness * roughness;
	cmat.localNormal = sampledNormal.rgb;
	cmat.emissive = sampledEmissive.rgb;
}
