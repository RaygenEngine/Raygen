#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "global.h"
#include "rtshared.h"
#include "random.h"
#include "sampling.glsl"

layout(set = 0, binding = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 2, binding = 0) uniform UBO_Camera {   
	vec3 position;
	float pad0;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	mat4 viewInv;
	mat4 projInv;
	mat4 viewProjInv; 
} cam;

layout(set = 4, binding = 0) uniform sampler2D normalsSampler;
layout(set = 4, binding = 1) uniform sampler2D baseColorSampler;
layout(set = 4, binding = 2) uniform sampler2D surfaceSampler;
layout(set = 4, binding = 3) uniform sampler2D emissiveSampler;
layout(set = 4, binding = 4) uniform sampler2D depthSampler;

layout(set = 5, binding = 0) uniform sampler2D rasterDirect;

layout(push_constant) uniform Constants
{
    int frame;
    int depth;
    int samples;
};


void main() {

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

    prd.result = vec3(0);
    for(uint smpl = 0; smpl < samples; ++smpl){

        uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frame * samples + smpl);

        float r1   = rnd(seed);
        float r2   = rnd(seed);

        // Subpixel jitter: send the ray through a different position inside the pixel each time,
        // to provide antialiasing.
        vec2 subpixel_jitter = (frame * samples + smpl) == 0 ? vec2(0.0f, 0.0f) : vec2(r1 - 0.5f, r2 - 0.5f);

        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + subpixel_jitter;
        const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2       d           = inUV * 2.0 - 1.0;


        vec4 origin    = cam.viewInv * vec4(0, 0, 0, 1);
        vec4 target    = cam.projInv * vec4(d.x, d.y, 1, 1);
        vec4 direction = cam.viewInv * vec4(normalize(target.xyz), 0);

        
        prd.origin = origin.rgb;
        prd.direction = direction.rgb;
        prd.throughput = vec3(1.f);
        prd.depth = 0;
        prd.debugDone = false;
        prd.done = false;
        prd.seed = seed;
        prd.smpl = smpl;

        do{

            // trace ray
            traceRayEXT(topLevelAs,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        origin.xyz,     // ray origin
                        tMin,           // ray min range
                        direction.xyz,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
            );

            // RR termination
            if(prd.depth >= 5){

                float p_spawn = max(prd.throughput.x, max(prd.throughput.y, prd.throughput.z));

                if(rnd(prd.seed) >= p_spawn){
                    break; 
                }

                prd.throughput /= p_spawn; 
            }
            
            origin.xyz    = prd.origin;
            direction.xyz = prd.direction;

        }while (prd.depth++ < depth && !prd.done);
    }

    //vec4 rasterColor = texture(rasterDirect, (vec2(gl_LaunchIDEXT.xy) + vec2(0.5))/ vec2(gl_LaunchSizeEXT.xy));
 
    vec3 curColor = prd.result / samples;

    // TODO: fix 
    // Do accumulation
    if(frame > 0){
        float a = 1.f / float(frame);
        vec3  prevColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(prevColor, curColor, a), 1.f));
    }
    else{
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(curColor, 1.f));
    }
}





