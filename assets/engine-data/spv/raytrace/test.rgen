#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "global.h"
#include "rtshared.h"
#include "random.h"
#include "sampling.h"
#include "fragment.h"
#include "shading-space.h"

layout(set = 0, binding = 0, rgba32f) uniform image2D image;
layout(set = 0, binding = 1, rgba32f) uniform image2D progressiveResult;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 2, binding = 0) uniform UBO_Camera {   
	vec3 position;
	float pad0;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	mat4 viewInv;
	mat4 projInv;
	mat4 viewProjInv; 
} cam;

layout(set = 4, binding = 0) uniform sampler2D normalsSampler;
layout(set = 4, binding = 1) uniform sampler2D baseColorSampler;
layout(set = 4, binding = 2) uniform sampler2D surfaceSampler;
layout(set = 4, binding = 3) uniform sampler2D emissiveSampler;
layout(set = 4, binding = 4) uniform sampler2D depthSampler;

layout(set = 5, binding = 0) uniform sampler2D rasterDirect;

layout(push_constant) uniform Constants
{
    int frame;
    int depth;
    int samples;
    int convergeUntilFrame;
};

vec3 RRTerminateOrTraceRay(vec3 nextOrigin, vec3 nextDirection, vec3 throughput, uint seed)
{
	
	// RR termination
	// TODO: check cumulative throughput
	//float p_spawn = max(throughput.x, max(throughput.y, throughput.z));

	//if(rnd(seed) >= p_spawn){
	//	return vec3(0); 
	//}

	//throughput /= p_spawn;
	

	prd.radiance = vec3(0);
	prd.depth = 1;
    prd.seed = seed;


    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

	// trace ray
	traceRayEXT(topLevelAs,     // acceleration structure
				rayFlags,       // rayFlags
				0xFF,           // cullMask
				0,              // sbtRecordOffset
				0,              // sbtRecordStride
				0,              // missIndex
				nextOrigin,     // ray origin
				tMin,           // ray min range
				nextDirection,  // ray direction
				tMax,           // ray max range
				0               // payload (location = 0)
	);

	return throughput * prd.radiance;
}

void main() {

    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

    if(frame >= convergeUntilFrame && convergeUntilFrame != 0) {
        vec3 indirect = imageLoad(progressiveResult, ivec2(gl_LaunchIDEXT.xy)).xyz;
        vec3 rasterColor = texture(rasterDirect, uv).rgb;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(indirect + rasterColor, 1.f));
        return;
    }

    float depth = texture(depthSampler, uv).r;







    if(depth == 1.f)
    {
        // sky
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0,0,0.3, 1.f));
        return;
    }









    Fragment frag = getFragmentFromGBuffer(
        depth,
        cam.viewProjInv,
        normalsSampler,
        baseColorSampler,
        surfaceSampler,
        emissiveSampler,
        uv);



    // diffuseColor = (1.0 - metallic) * albedo;
    vec3 diffuseColor = frag.diffuseColor;
    // f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + albedo * metallic;
    vec3 f0 = frag.f0;
    // a = roughness roughness;
    float a = frag.a;

    vec3 hitPoint = frag.position;

    vec3 V = normalize(cam.position - hitPoint);

    vec3 Ns = frag.normal;
    vec3 Ts, Bs;
    computeOrthonormalBasis(Ns, Ts, Bs); 

    mat3 TBNs = mat3(Ts, Bs, Ns);
    mat3 invTBNs = transpose(TBNs);

    vec3 wo = normalize(invTBNs * V);


    vec3 hitValue = vec3(0);
    
    for(uint smpl = 0; smpl < samples; ++smpl){
		//hitValue += hitPoint;
        // PERF:
        uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frame * samples + smpl);

        //vec3 Ng_s = normalize(invTBNs * Ng);
       // if(wo.z < 0){
        //    if(dot(V, facen) < 0) return; // backface culling
       //     Ng_s = normalize(invTBNs * facen);
	   // }

        // Diffuse 'reflection'
        {
            vec2 u = vec2(rnd(seed), rnd(seed));
            vec3 wi = cosineSampleHemisphere(u);
			      // hitValue += wi;
           // bool reflect = dot(Ng_s, wi) * dot(Ng_s, wo) > 0;

            float cosTheta = CosTheta(wi);
			// PERF: reflect
            if(cosTheta > 0)
            {
                float pdf = cosTheta * INV_PI;
            
                vec3 throughput = LambertianReflection(wo, wi, diffuseColor) * cosTheta / pdf;

                // RR termination
                hitValue += RRTerminateOrTraceRay(hitPoint, TBNs * wi, throughput, seed);
            }
        }
        
        // Glossy reflection
        {
            // sample new direction wi and its pdfs based on distribution of the GGX BRDF
            vec2 u = vec2(rnd(seed), rnd(seed));
            vec3 wh  = TrowbridgeReitzDistribution_Sample_wh(wo, u, a, a);

            vec3 wi  = reflect(wo, wh);

            //bool reflect = dot(Ng_s, wi) * dot(Ng_s, wo) > 0;
        
            float cosTheta = CosTheta(wi);

            if(cosTheta > 0)
            {
                vec3 brdf_r = MicrofacetReflection(wo, wi, a, a, f0);

                float pdf = TrowbridgeReitzSamplePdf(wo, wh, a, a) / (4 * dot(wo, wh));

                vec3 throughput = brdf_r * cosTheta  / pdf;

                hitValue += RRTerminateOrTraceRay(hitPoint, TBNs * wi, throughput, seed);
            }
        }
    }

    vec3 rasterColor = texture(rasterDirect, uv).rgb;

    vec3 curColor = (hitValue / samples);

    // TODO: fix 
    // Do accumulation
    if(frame > 0){
        float a = 1.f / float(frame);
        vec3  prevColor = imageLoad(progressiveResult, ivec2(gl_LaunchIDEXT.xy)).xyz;
        vec3 finalIndirect = mix(prevColor, curColor, a);

        imageStore(progressiveResult, ivec2(gl_LaunchIDEXT.xy), vec4(finalIndirect, 1.f));
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalIndirect + rasterColor, 1.f));
    }
    else{
        imageStore(progressiveResult, ivec2(gl_LaunchIDEXT.xy), vec4(curColor, 1.f));
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(curColor + rasterColor, 1.f));
    }


}











