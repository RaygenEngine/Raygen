#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "global.h"
#include "rtshared.h"
#include "random.h"
#include "sampling.glsl"


layout(set = 0, binding = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAs;

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 2, binding = 0) uniform UBO_Camera {   
	vec3 position;
	float pad0;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	mat4 viewInv;
	mat4 projInv;
	mat4 viewProjInv; 
} cam;

#define SPP 3
#define BOUNCES 8

void main() {

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

    prd.result = vec3(0);
    for(int i = 0; i < SPP; ++i){

        uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, SPP + i);

        float r1   = rnd(seed);
        float r2   = rnd(seed);

        // Subpixel jitter: send the ray through a different position inside the pixel each time,
        // to provide antialiasing.
        vec2 subpixel_jitter = (SPP + i) == 0 ? vec2(0.0f, 0.0f) : vec2(r1 - 0.5f, r2 - 0.5f);

        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + subpixel_jitter;
        const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2       d           = inUV * 2.0 - 1.0;


        vec4 origin    = cam.viewInv * vec4(0, 0, 0, 1);
        vec4 target    = cam.projInv * vec4(d.x, d.y, 1, 1);
        vec4 direction = cam.viewInv * vec4(normalize(target.xyz), 0);

        
        prd.origin = origin.rgb;
        prd.direction = direction.rgb;
        prd.throughput = vec3(1.f);
        prd.depth = 0;
        prd.debugDone = false;
        prd.done = false;
        prd.seed = seed;

        for (;;){

            // trace ray
            traceRayEXT(topLevelAs,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        origin.xyz,     // ray origin
                        tMin,           // ray min range
                        direction.xyz,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
            );

            // RR termination
            if(prd.depth >= 1){

                float p_spawn = max(prd.throughput.x, max(prd.throughput.y, prd.throughput.z));

                if(rnd(prd.seed) >= p_spawn){
                    break; 
                }

                prd.throughput /= p_spawn; 
            }
            
            if(prd.done || ++prd.depth >= BOUNCES){
                break;
            }

            origin.xyz    = prd.origin;
            direction.xyz = prd.direction;
        }
    }

    vec4 outColor = vec4(prd.result / SPP, 1);

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), outColor);
}


