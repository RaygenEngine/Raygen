#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#include "global.glsl"
#include "rt-global.glsl"

#include "random.glsl"
#include "sampling.glsl"
#include "fragment.glsl"
#include "bsdf.glsl"
#include "attachments.glsl"
#include "onb.glsl"
#include "sky.glsl"

layout(set = 1, binding = 0) uniform UBO_Camera {   
	vec3 position;
	float pad0;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	mat4 viewInv;
	mat4 projInv;
	mat4 viewProjInv; 
} cam;

layout(set = 2, binding = 0, rgba32f) uniform image2D image;
layout(set = 2, binding = 1, rgba32f) uniform image2D progressiveResult;
layout(set = 2, binding = 2, rgba32f) uniform image2D momentsBuffer;

layout(location = 0) rayPayloadEXT hitPayload prd;


#include "raytrace/rt-indirect.glsl"

void WriteSky(); 

struct ReprojectionData {
	vec3 color;
	vec2 moments;
	int historyLength; // 0 means reprojection was invalid
};

ReprojectionData GetReprojection(vec2 uv);
 
void main() {

	vec2 uv = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
	float fragDepth = texture(g_DepthSampler, uv).r;
	if(fragDepth >= 1.)
	{
		// sky
		WriteSky();
		return; 
	}

	if(frame >= convergeUntilFrame && convergeUntilFrame != 0) {
		vec3 indirect = imageLoad(progressiveResult, ivec2(gl_LaunchIDEXT.xy)).xyz;
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(indirect, 1.));
		return;
	}

	Fragment frag = getFragmentFromGBuffer(
		fragDepth,
		cam.viewProjInv,
		g_NormalSampler,
		g_ColorSampler,
		g_SpecularSampler,
		g_EmissiveSampler,
		uv);

	// Extract BrdfInfo
	FragBrdfInfo brdfInfo;
	brdfInfo.diffuseColor = frag.diffuseColor;
	brdfInfo.f0 = frag.f0;
	brdfInfo.a = frag.a;

	// Extract SpaceInfo
	FsSpaceInfo fragSpace = GetFragSpace_World(frag.normal, frag.position, cam.position);

	
	
	ReprojectionData reproj = GetReprojection(uv);
	int moments = reproj.historyLength;


	vec3 accumColor = vec3(0);
	uint actualSamples = 1;


	if (moments == 0) {
	   actualSamples = 10; //max(3u - moments, 1u);
	}
	
	
	actualSamples *= samples;
	for(uint smpl = 0; smpl < actualSamples && depth > 0; ++smpl){
		// NOTE: Don't forget to initialize the ray here. 
		prd.seed = tea16(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frame * samples + smpl); // PERF:
		prd.depth = 0;
		prd.accumThroughput = vec3(1.f);
		accumColor += TraceIndirect(fragSpace, brdfInfo);
	}

	vec3 curColor = (accumColor / actualSamples);


	// Do accumulation
	if(frame > 0){
		vec2 motion = texture(g_VelocitySampler, uv).xy;
		vec2 posPrev = vec2(gl_LaunchIDEXT.xy) - vec2(motion * gl_LaunchSizeEXT.xy);
		vec3 prevColor = reproj.color;

		if (abssum(prevColor) <= 0) {
			moments = 0;

		}

		float a = 0.05;
		a = max(1.f / float(moments + 1), 0.05);

		
		bool progressive = false;
		if (progressive) {
			a = 1.f / float(frame);
		}

		vec3 finalIndirect = mix(prevColor, curColor, a);
		
		
		//vec3 finalIndirect = mix(prevColor, curColor, a);
		
 
		imageStore(progressiveResult, ivec2(gl_LaunchIDEXT.xy), vec4(finalIndirect, 1.f));

		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalIndirect, 1.f));
//		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(abs(prevUv - uv), 0.f, 1.f));
	}
	else{
		imageStore(progressiveResult, ivec2(gl_LaunchIDEXT.xy), vec4(curColor, 1.f));
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(curColor, 1.f));
	}
	imageStore(momentsBuffer, ivec2(gl_LaunchIDEXT.xy), vec4(moments + 1., fragDepth, 0., 0.));
}

void WriteSky() {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2       d           = inUV * 2.0 - 1.0;

	vec4 origin    = cam.viewInv * vec4(0, 0, 0, 1);
	vec4 target    = cam.projInv * vec4(d.x, d.y, 1, 1);
	vec4 direction = cam.viewInv * vec4(normalize(target.xyz), 0);        
	
	vec3 color = GetSkyColor(origin.xyz, direction.xyz);
	
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
}

//
//  PRE PROCESS (reproject)
//

bool IsReprojValid(ivec2 coord, float expectedPrevDepth)
{
	if (coord.x < 0 || coord.y < 0 || coord.x >= gl_LaunchSizeEXT.x || coord.y > gl_LaunchSizeEXT.y) {
		return false;
	}

	// perf Avoid image load here
	const float prevDepth = imageLoad(momentsBuffer, coord).y;
	if (abs(expectedPrevDepth - prevDepth) > 5e-3) {
		return false;
	}
	return true;
}


vec4 ReprojSample(vec2 sampleUv, float expectedPrevDepth)
{
	ivec2 pixelPos = ivec2(floor(sampleUv));
	ivec2 offset[4] = { ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1) };

	float sumw = 0;
	float x = fract(sampleUv.x);
	float y = fract(sampleUv.y);

	float w[4] = { 
		(1 - x) * (1 - y),
		      x * (1 - y),
		(1 - x) * y,
		      x * y 
	};

	vec4 result = vec4(0);
	float sumW = 0;

	for (int sampleIdx = 0; sampleIdx < 4; sampleIdx++) {
		ivec2 loc = pixelPos + offset[sampleIdx];
		if (IsReprojValid(loc, expectedPrevDepth)) {
			result += w[sampleIdx] * imageLoad(progressiveResult, loc);
			sumW += w[sampleIdx];
		}
	}

	if (sumW > 0) {
		result /= sumW;
	}

	return result;
}

ReprojectionData GetReprojection(vec2 uv) {
	// xy: ScreenSpace (uv) motion vector
	// z: expected previous depth
	const vec4 motionSample = texture(g_VelocitySampler, uv);

	const vec2 motion = motionSample.xy;
	const float expectedDepth = motionSample.z;

	const vec2 posPrev = vec2(gl_LaunchIDEXT.xy) - vec2(motion * gl_LaunchSizeEXT.xy);

	ReprojectionData reproj;
	reproj.color = ReprojSample(posPrev, expectedDepth).xyz;

    
    vec2 prevUv = uv - motionSample.xy;
    ivec2 prevIuv = ivec2((prevUv  * gl_LaunchSizeEXT.xy) - vec2(0.5));
    const vec4 momentsSample = imageLoad(momentsBuffer, prevIuv);
	int historyLength = int(round(momentsSample.x));

	reproj.historyLength = historyLength;

	return reproj;
}

